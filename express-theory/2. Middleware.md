# what middleware is (mentally)

a **middleware** is just a function that gets a `req`, a `res`, and a `next`. it can:

- **read/modify** the request (`req.headers`, `req.body`, `req.params`, `req.query`, `req.user`, etc.)
    
- **short-circuit** and **send a response**
    
- or **pass control** to the next middleware/route by calling `next()`
    
- if it encounters an error, call `next(err)` (in v5, **throwing** also works inside async handlers—express forwards it)
    

```js
// signature: (req, res, next) => void | Promise<void>
function someMiddleware(req, res, next) {
  // do stuff...
  next(); // continue
}
```

## the middleware pipeline (order matters!)

express builds a **stack** in the **exact order** you register things:

1. global middleware (`app.use(...)`)
    
2. routers mounted via `app.use('/base', router)`
    
3. routes (`app.get/post/...`)
    
4. 404 handler (catch-all, no path)
    
5. error handler (four args)
    

> if you put `express.json()` _after_ your routes, `req.body` will be undefined in those routes. if you put your 404 handler too early, it will swallow later routes.

---

# built-in middleware (v5)

most “core” needs are covered by express itself:

```js
const express = require('express');
const app = express();

// parses application/json bodies; throws SyntaxError on invalid JSON
app.use(express.json({ limit: '1mb' }));

// parses application/x-www-form-urlencoded bodies (HTML forms)
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// serves static files (css/js/img) from ./public at /
app.use(express.static('public', { maxAge: '1d', etag: true }));

// also available:
app.use(express.text()); // raw text bodies
app.use(express.raw({ type: 'application/octet-stream' })); // raw buffers
```

### important details

- **content-type matters**: `express.json()` only runs when `Content-Type: application/json` (or matches `type` option).
    
- **body can be consumed once**: if a custom middleware reads the request stream **before** `express.json()`, the parser won’t see anything. order matters.
    
- **invalid json** triggers a `SyntaxError`. you should have an error handler to turn that into a nice 400.
    

---

# third-party middleware you’ll actually use

- **morgan** – request logging
    
- **cors** – CORS headers + preflight support
    
- **helmet** – security headers
    
- **compression** – gzip/deflate responses
    
- **cookie-parser** – parse `req.cookies`
    
- **express-rate-limit** – simple rate limiting
    
- **multer** – file uploads (`multipart/form-data`)
    

```js
const morgan = require('morgan');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');

app.use(helmet());                // secure headers
app.use(cors());                  // default: allows all origins; configure in prod
app.use(morgan('dev'));           // concise dev logs
app.use(compression());           // gzip responses (put before routes)
```

### CORS gotchas

- browsers may send **OPTIONS preflight** for non-simple requests. `cors()` handles it; if you customize, remember:
    
    ```js
    app.options('*', cors()); // respond to all preflights
    ```
    

---

# custom middleware (patterns you’ll reuse)

## simple “pass data” middleware

```js
app.use((req, res, next) => {
  req.requestTime = Date.now();
  res.locals.startedAt = new Date(); // available to views/handlers
  next();
});
```

## parameterized (factory) middleware

```js
const makeLogger = (label) => (req, res, next) => {
  console.log(`[${label}] ${req.method} ${req.originalUrl}`);
  next();
};

app.use(makeLogger('API'));
```

## async middleware (v5 auto-handles thrown errors)

```js
app.use(async (req, res, next) => {
  try {
    // await something…
    next();
  } catch (err) {
    next(err); // or just throw err; (v5)
  }
});
```

## route-level middleware chains

```js
const requireAuth = (req, res, next) => {
  if (!req.headers.authorization) return res.status(401).json({ error: 'unauthorized' });
  next();
};

app.get('/profile',
  morgan('tiny'),
  requireAuth,
  (req, res) => res.json({ ok: true })
);
```

## router-level middleware + modularization

```js
const { Router } = require('express');
const users = Router();

users.use((req, res, next) => { console.log('users router hit'); next(); });
users.get('/', (req, res) => res.send('all users'));
users.get('/:id(\\d+)', (req, res) => res.send(`user ${req.params.id}`));

app.use('/users', users);
```

## `router.param` for param preprocessing

```js
users.param('id', (req, res, next, id) => {
  if (!/^\d+$/.test(id)) return res.status(400).json({ error: 'invalid id' });
  // attach preloaded data if you want: req.user = …
  next();
});
```

---

# middleware control flow and `next()`

- call `next()` to pass control
    
- **send a response OR call `next()` — not both**
    
- call `next(err)` to skip the rest of normal middleware and jump to **error handlers**
    
- in **Express v5**, throwing inside an async handler is equivalent to `next(err)`:
    
    ```js
    app.get('/async', async (req, res) => {
      const data = await riskyCall(); // if this rejects, express goes to error handler
      res.json(data);
    });
    ```
    

> `next('route')` (advanced): in a route with multiple handlers, `next('route')` skips the remaining handlers for the **current route** and continues matching the next route. you’ll use it rarely; it doesn’t work from `app.use` (only within routes/router).

---

# 404 & error-handling middleware (must-have)

**404** (last non-error middleware):

```js
app.use((req, res) => {
  res.status(404).json({ error: 'not found' });
});
```

**error handler** (four args):

```js
app.use((err, req, res, next) => {
  // if headers already sent, delegate to default
  if (res.headersSent) return next(err);

  const status =
    err.status || (err.type === 'entity.parse.failed' ? 400 : 500);

  res.status(status).json({
    error: err.message || 'internal server error',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
  });
});
```

notes:

- put this **after all** routes/middleware
    
- body-parser JSON errors arrive here with a `SyntaxError` (often `err.type === 'entity.parse.failed'`)
    

---

# production ordering blueprint (copy-paste worthy)

```js
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const morgan = require('morgan');
const compression = require('compression');
const rateLimit = require('express-rate-limit');

const app = express();

// 1) security & infra
app.use(helmet());
app.use(cors({ origin: ['https://your.app'], credentials: true }));
app.use(morgan(process.env.NODE_ENV === 'production' ? 'combined' : 'dev'));
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 300 }));

// 2) body parsers (before your routes)
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// 3) static (before routes when serving assets)
app.use(express.static('public', { maxAge: '1d' }));

// 4) app locals/custom middleware
app.use((req, res, next) => { res.locals.requestId = crypto.randomUUID(); next(); });

// 5) routers / routes
app.use('/api/users', require('./routes/users'));   // modular routers
app.use('/api/products', require('./routes/products'));

// 6) 404
app.use((req, res) => res.status(404).json({ error: 'not found' }));

// 7) centralized error handler
app.use((err, req, res, next) => {
  if (res.headersSent) return next(err);
  console.error(err);
  res.status(err.status || 500).json({ error: err.message || 'server error' });
});

app.listen(5000, () => console.log('listening on :5000'));
```

---

# common gotchas (you’ll avoid them now)

- **middleware order**: parsers/loggers/security should be registered **before** routes that need them.
    
- **double responses**: don’t `res.send()` and then `next()`.
    
- **unhandled rejections**: in v5, thrown async errors go to the error handler; in v4 they crash unless you `next(err)` or use `express-async-errors`.
    
- **body size**: set `limit` to avoid giant payloads (DoS vector).
    
- **multipart**: `express.json()` does **not** parse `multipart/form-data`; use **multer**.
    
- **CORS preflight**: expect and allow `OPTIONS` requests for APIs.
    
- **performance**: never do expensive sync work in middleware; keep CPU-heavy tasks off the event loop (worker threads/queues).
    

---

# quick practice checklist for you

1. add `helmet`, `cors`, `morgan`, `compression`
    
2. add `express.json()` and return a nice 400 on bad JSON
    
3. build a tiny `auth` middleware that checks a header and attaches `req.user`
    
4. mount a `/users` router that uses `router.param('id')` for validation
    
5. implement centralized error handler and a proper 404
    
