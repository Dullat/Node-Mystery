

# what `fs` actually gives you

- **two api styles**
    
    - **callback-based**: `fs.readFile(path, cb)`
        
    - **promises-based**: `const fs = require('fs/promises')` → `await fs.readFile(path)`
        
- **sync variants** for each: `fs.readFileSync`, etc. (use sparingly)
    
- **streams** for large data: `fs.createReadStream` / `fs.createWriteStream`
    
- **low-level fd ops**: `fs.open`, `fs.read`, `fs.write`, `fs.close`
    
- **dirs**: `readdir`, `opendir`, `mkdir`, `rm`, `rename`
    
- **metadata**: `stat`, `lstat`, `fstat` (sizes, times, isFile, isDirectory, etc.)
    
- **perms/ownership**: `chmod`, `chown`
    
- **links**: `link` (hard), `symlink` (soft)
    
- **watching**: `fs.watch`, `fs.watchFile` (with caveats)
    

---

# best-practice rules (read these!)

1. **prefer promises api** (`fs/promises`) + `await` for clarity.
    
2. **only use sync** at process startup or small CLIs; never on hot paths.
    
3. **for big files** use **streams** (copy, transform) to avoid memory blowups.
    
4. **write files atomically** when you can (write to temp, then `rename`).
    
5. **never trust user paths** → sanitize with `path.resolve` and validate inside your allowed root to avoid path traversal (`..`).
    
6. **avoid TOCTOU** (“check-then-open” race). use **flags** (`'wx'`, `'ax'`) for exclusivity.
    
7. **`fs.watch` is flaky** across platforms; for serious use, a library like `chokidar` is better (later when you’re in npm-land).
    

---

# the flags (super important)

- `'r'` read
    
- `'r+'` read/write (must exist)
    
- `'w'` write (truncate or create)
    
- `'w+'` read/write (truncate or create)
    
- `'a'` append (create if missing)
    
- `'a+'` read/append
    
- add **`x`** for exclusive create (fail if exists): `'wx'`, `'ax'`
    
- encodings: `'utf8'` (string) or omit for `Buffer`
    

---

# quick recipes (promises api)

## 1) read text file (three ways)

```js
const fs = require('fs/promises');

// a) as string
const text = await fs.readFile('notes.txt', 'utf8');

// b) as Buffer
const buf = await fs.readFile('notes.txt'); // <Buffer ...>

// c) JSON
const obj = JSON.parse(await fs.readFile('data.json', 'utf8'));
```

## 2) write/append (safe patterns)

```js
const fs = require('fs/promises');

// simple overwrite (creates or truncates)
await fs.writeFile('out.txt', 'hello\n', 'utf8');

// append
await fs.appendFile('out.txt', 'more\n', 'utf8');

// atomic-ish write (temp → rename)
const tmp = 'out.txt.tmp';
await fs.writeFile(tmp, 'new contents\n');
await fs.rename(tmp, 'out.txt'); // rename is atomic on same filesystem
```

## 3) copy/move/delete

```js
await fs.copyFile('a.txt', 'b.txt');               // fast, native
await fs.rename('b.txt', 'moved.txt');             // move/rename (fails across devices)
await fs.rm('moved.txt', { force: true });         // delete file
await fs.rm('someDir', { recursive: true, force: true }); // delete dir tree
```

## 4) ensure directory exists

```js
await fs.mkdir('logs/app', { recursive: true });
```

## 5) list a directory (two clean ways)

```js
const path = require('path');
const fs = require('fs/promises');

// a) readdir with dirent
for (const dirent of await fs.readdir('photos', { withFileTypes: true })) {
  if (dirent.isFile()) console.log('file:', dirent.name);
  if (dirent.isDirectory()) console.log('dir:', dirent.name);
}

// b) modern async iterator
for await (const dirent of await fs.opendir('photos')) {
  console.log(dirent.name, dirent.isFile() ? 'file' : 'dir');
}
```

## 6) file metadata (stat vs lstat)

```js
const s = await fs.lstat('target'); // lstat does not follow symlinks
console.log({
  size: s.size,
  mtime: s.mtime,
  isFile: s.isFile(),
  isDir: s.isDirectory(),
  isSym: s.isSymbolicLink(),
});
```

## 7) permissions & ownership

```js
// mode is octal — use 0o notation
await fs.chmod('script.sh', 0o755);
// chown needs uid/gid (careful on cross-platform)
await fs.chown('file.txt', process.getuid?.() ?? 0, process.getgid?.() ?? 0);
```

---

# streams (the right way)

## 8) stream read/write with backpressure handled

```js
const fsSync = require('fs');               // streams live in callback API
const { pipeline } = require('stream/promises');

await pipeline(
  fsSync.createReadStream('bigfile.dat'),
  fsSync.createWriteStream('bigfile_copy.dat')
);
```

### createReadStream / createWriteStream options

```js
fsSync.createReadStream('file', {
  encoding: null,          // or 'utf8'
  highWaterMark: 64 * 1024, // default buffer size
  start: 0, end: 9999,     // byte range
});

fsSync.createWriteStream('file', {
  flags: 'w',              // or 'a', 'wx'
});
```

## 9) stream file to HTTP response (common in servers)

```js
const http = require('http');
const fsSync = require('fs');
const { pipeline } = require('stream/promises');

http.createServer(async (req, res) => {
  if (req.url === '/video') {
    res.writeHead(200, { 'Content-Type': 'video/mp4' });
    try {
      await pipeline(
        fsSync.createReadStream('movie.mp4'),
        res
      );
    } catch (err) {
      res.writeHead(500); res.end('error');
    }
  } else res.end('ok');
}).listen(3000);
```

---

# low-level file descriptor ops (when you need control)

## 10) open → read → write → close

```js
const fs = require('fs/promises');

const fh = await fs.open('notes.txt', 'r');
try {
  const { bytesRead, buffer } = await fh.read({ buffer: Buffer.alloc(1024), position: 0 });
  console.log('read', bytesRead, 'bytes');
} finally {
  await fh.close();
}
```

## 11) exclusive create to avoid races

```js
await fs.writeFile('users.json', '[]', { flag: 'wx' }); // throws if exists
```

---

# links & symlinks

```js
// hard link (same inode)
await fs.link('source.txt', 'hardlink.txt');

// symbolic link (like a shortcut)
await fs.symlink('source.txt', 'softlink.txt');

// resolve where a symlink points without following
const linkStat = await fs.lstat('softlink.txt');   // isSymbolicLink() → true
```

---

# watching files (know the caveats)

```js
const watcher = fsSync.watch('content', { recursive: false }, (event, filename) => {
  console.log(event, filename); // events may coalesce; can miss changes
});

// alternative: fs.watchFile('file', { interval: 500 }, (curr, prev) => { ... })
// tip: for robust cross-platform watching in real apps, use 'chokidar'
```

**Gotchas:** not 100% reliable across OSes; events can drop or merge; recursive support varies.

---

# common error codes to recognize

- `ENOENT` – no such file/dir (missing path)
    
- `EEXIST` – file exists (when using exclusive flags)
    
- `EPERM` / `EACCES` – permission denied
    
- `EXDEV` – cross-device rename not permitted (use copy+delete instead)
    
- `EBUSY` – file is busy/locked (Windows especially)
    

---

# cross-platform notes

- **paths**: always build with `path.join` / `path.resolve`; never hand-type `/` or `\`.
    
- **modes/perms**: POSIX vs Windows semantics differ; `chmod` may no-op on Windows.
    
- **newlines**: text files may contain `\r\n` on Windows; normalize when needed.
    

---

# security checklist (for servers & CLIs)

- **path traversal**: lock a root and validate:
    
    ```js
    const root = path.resolve('public');
    const target = path.resolve(root, userPath);
    if (!target.startsWith(root + path.sep)) throw new Error('bad path');
    ```
    
- **temp files**: use `os.tmpdir()` and unique names (e.g., `crypto.randomUUID()`).
    
- **atomic writes**: temp + rename; consider `fsync` on critical data (databases do more).
    

---

# a tiny “fs toolkit” you can reuse

```js
// fsx.js
const fsp = require('fs/promises');
const fss = require('fs');
const path = require('path');
const { pipeline } = require('stream/promises');

exports.readJSON = async (p) => JSON.parse(await fsp.readFile(p, 'utf8'));
exports.writeJSON = async (p, obj) =>
  await fsp.writeFile(p, JSON.stringify(obj, null, 2) + '\n');

exports.ensureDir = (dir) => fsp.mkdir(dir, { recursive: true });

exports.atomicWrite = async (p, data) => {
  const tmp = p + '.' + Date.now() + '.tmp';
  await fsp.writeFile(tmp, data);
  await fsp.rename(tmp, p);
};

exports.copyFile = (src, dst) => fsp.copyFile(src, dst);

exports.copyBig = (src, dst) => pipeline(
  fss.createReadStream(src),
  fss.createWriteStream(dst, { flags: 'wx' })
);

exports.walk = async function * walk(dir) {
  for await (const dirent of await fsp.opendir(dir)) {
    const p = path.join(dir, dirent.name);
    if (dirent.isDirectory()) yield* walk(p);
    else if (dirent.isFile()) yield p;
  }
};
```

---

# practice tasks (do these and you’ll own `fs`)

1. **log rotator**: append logs to `app.log`; when > 10MB, rotate to `app-YYYYMMDD.log` atomically.
    
2. **dir sync**: recursively copy `srcDir` → `dstDir` using streams; preserve timestamps.
    
3. **simple asset server**: HTTP server that safely serves files from `/public` using `createReadStream` + range requests (bonus).
    
4. **watch & rebuild**: watch a `content/` folder; on change, rebuild an output file (generate a `manifest.json` with file sizes & hashes).
    

---
