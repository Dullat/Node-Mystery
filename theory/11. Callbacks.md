Asynchronous Callbacks in Node.js**

### **What is a Callback?**

A **callback** is a function you pass into another function to be executed later — often after an async task finishes.

**Example:**

```js
function greet(name, callback) {
  console.log(`Hello, ${name}`);
  callback();
}

greet("Jashan", () => {
  console.log("Greeting complete!");
});
```


---
```js
const fs = require('fs').promises; // Use Promise-based API

async function greet(name) {
    if (!name) throw new Error('No name given');

    const data = await fs.readFile('sample.txt', 'utf8');
    return `Hi ${name} here is your note:\n${data}`;
}

greet('dullat')
    .then(message => console.log(message))
    .catch(err => console.error(err.message));

```

---

### **Synchronous vs Asynchronous Callbacks**

#### **Synchronous Callback**

Runs immediately, during the function execution:

```js
[1, 2, 3].forEach(num => console.log(num));
console.log("Done!");
```

**Output:**

```
1
2
3
Done!
```

---

#### **Asynchronous Callback**

Runs later, after async work finishes:

```js
setTimeout(() => {
  console.log("Async callback done!");
}, 1000);

console.log("Code continues running...");
```

**Output:**

```
Code continues running...
Async callback done!
```

💡 Here, `setTimeout` schedules the callback for later (timers phase).

---

### **Async Callbacks in Node Core APIs**

Most Node APIs use async callbacks for non-blocking I/O:

```js
const fs = require('fs');

fs.readFile('test.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log("File contents:", data);
});

console.log("Reading file...");
```

**Output:**

```
Reading file...
File contents: <contents>
```

💡 `readFile` delegates work to libuv → OS reads file → event loop schedules the callback in poll phase.

---

### **The “Error-First” Callback Pattern**

- Node uses a standard format for async callbacks:
    

```js
(err, result) => { ... }
```

- **If error:** `err` is set, `result` is `undefined`
    
- **If success:** `err` is `null`, `result` contains the value
    

Example:

```js
fs.readFile('missing.txt', 'utf8', (err, data) => {
  if (err) {
    console.error("Error reading file:", err.message);
    return;
  }
  console.log(data);
});
```

---

### **Drawbacks of Callbacks**

- **Callback Hell:** Nested callbacks that become hard to read and maintain:
    

```js
fs.readFile('file1.txt', 'utf8', (err, data1) => {
  fs.readFile('file2.txt', 'utf8', (err, data2) => {
    fs.readFile('file3.txt', 'utf8', (err, data3) => {
      console.log(data1, data2, data3);
    });
  });
});
```

- Hard to handle errors across multiple async steps.
    
- Solution: **Promises** and **async/await**.
    

---

💡 **Key Takeaway for You:**  
Now that you understand **event loop priorities**, you know exactly **when** async callbacks will run in Node:

- I/O callbacks → poll phase
    
- Timers → timers phase
    
- Immediate callbacks → check phase
    
- All followed by microtasks (nextTick, Promises)
    

---
