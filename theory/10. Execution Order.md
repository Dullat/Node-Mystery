

This is **the core** of async behavior in Node, and it’s where **libuv’s event loop + V8’s microtask queue** work together.

---

## **12. Execution Order & Queues in Node.js**

### **Two Worlds to Remember**

When you run async code in Node:

1. **JavaScript side (V8 engine)**
    
    - Handles **synchronous execution**.
        
    - Maintains a **microtask queue** for promises and `process.nextTick()`.
        
2. **libuv (C library)**
    
    - Manages **macrotasks** like timers, I/O, and `setImmediate`.
        
    - Runs the **event loop phases**.
        

---

## **1. Microtasks vs Macrotasks**

### **Microtasks** (Highest Priority)

- Executed **immediately after** the current JS function finishes, **before** the event loop continues.
    
- **Two types in Node:**
    
    - **`process.nextTick()`** → Node-specific, runs **before** other microtasks.
        
    - **Promises** (`.then()`, `.catch()`, `.finally()`).
        

**Priority:**

```
process.nextTick → Promises
```

---

### **Macrotasks**

- Scheduled by libuv’s event loop phases.
    
- Examples:
    
    - `setTimeout`
        
    - `setInterval`
        
    - `setImmediate`
        
    - I/O callbacks (like `fs.readFile`)
        

---

## **2. Event Loop Phases & Where Things Go**

Here’s the **simplified order per tick**:

```
[Microtasks: process.nextTick() + Promises]  
→ Timers Phase (setTimeout, setInterval)  
→ Pending Callbacks  
→ Idle, Prepare (internal)  
→ Poll Phase (I/O callbacks)  
→ Check Phase (setImmediate)  
→ Close Callbacks
```

💡 After **every phase**, Node checks the **microtask queue** again — meaning `nextTick` and promises can run **between phases**.

---

## **3. Execution Order Examples**

### Example 1 — `process.nextTick` vs Promise

```js
setTimeout(() => console.log("⏳ Timeout"), 0);
setImmediate(() => console.log("⚡ Immediate"));
Promise.resolve().then(() => console.log("💎 Promise"));
process.nextTick(() => console.log("🚀 NextTick"));
```

**Output:**

```
🚀 NextTick     // Highest priority
💎 Promise      // Then promises
⏳ Timeout      // Timers phase
⚡ Immediate    // Check phase
```

---

### Example 2 — `setTimeout` vs `setImmediate`

- If both are called from the **main script**:
    

```js
setTimeout(() => console.log("⏳ Timeout"), 0);
setImmediate(() => console.log("⚡ Immediate"));
```

**Possible Output:**

```
⏳ Timeout
⚡ Immediate
```

(Because timers phase comes before check phase **in the first tick**.)

- If both are inside an I/O callback:
    

```js
const fs = require('fs');

fs.readFile(__filename, () => {
  setTimeout(() => console.log("⏳ Timeout"), 0);
  setImmediate(() => console.log("⚡ Immediate"));
});
```

**Output:**

```
⚡ Immediate
⏳ Timeout
```

(Because after I/O, the next phase is **check** — so `setImmediate` wins.)

---

## **4. Analogy**

Think of it like an airport:

- **`process.nextTick`** → VIP passengers who board before anyone else.
    
- **Promises** → Business class passengers (still board before regular).
    
- **Timers (`setTimeout`)** → Regular passengers, board when gate opens (timers phase).
    
- **`setImmediate`** → Last call passengers (check phase).
    
- **I/O callbacks** → Arrivals waiting for connection flights.
    

---

## **5. Rules to Remember**

1. **`process.nextTick` > Promises > Anything else**
    
2. **Timers phase comes before Check phase** — unless inside I/O.
    
3. Microtasks run **between every event loop phase**.
    
4. Long-running sync code delays **everything**, even microtasks.
    

---
