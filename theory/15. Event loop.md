

# Deep dive: Node’s event loop (V8 + microtasks + libuv)

**Quick summary:**

- **V8** runs your JavaScript (call stack).
    
- **V8 microtask queue** holds Promise jobs and `queueMicrotask()` (job queue).
    
- **Node** has an extra, higher-priority queue: **`process.nextTick` queue** (Node-specific).
    
- **libuv** runs the _event loop_ with phases (timers, poll, check, …) and manages I/O and the thread pool.
    
- After each JS callback (each “turn”), Node drains `process.nextTick` first, then the V8 microtask queue, **then** continues into the libuv phases.
    

---

# Core components and their roles

- **Call stack (V8):** executes JavaScript synchronously.
    
- **process.nextTick queue (Node):** node-specific queue processed _before_ microtasks. Use sparingly — can starve the loop.
    
- **Microtask queue (V8 job queue):** Promise callbacks and `queueMicrotask()` — drained to completion after the current JS turn but **after** `nextTick`.
    
- **libuv event loop:** macrotasks (timers, I/O callbacks, `setImmediate`, close). It runs in repeated ticks — each tick executes a sequence of phases.
    
- **libuv thread pool:** default 4 threads (used for certain operations like some file I/O, crypto, compression) — offloads work so the main JS thread stays free.
    

---

# The libuv phases (simplified, in order per tick)

1. **Timers phase** — run callbacks for expired `setTimeout` / `setInterval`.
    
2. **Pending callbacks** — system-related callbacks (rare).
    
3. **Idle, prepare** — internal.
    
4. **Poll phase** — retrieve I/O events and execute their callbacks. If there are no I/O events, poll may block waiting for I/O _unless_ there are `setImmediate` callbacks queued (in which case it will end poll and move on).
    
5. **Check phase** — run `setImmediate` callbacks.
    
6. **Close callbacks** — run `close` events (e.g. `socket.on('close')`).
    

**Important:** _After each callback execution, Node drains `process.nextTick` and then the microtask queue_ before moving on.

---

# Priority rules (short, exact)

1. **Synchronous code** (call stack) runs first.
    
2. **`process.nextTick()`** queue runs _immediately_ after current code finishes. (Highest priority.)
    
3. **V8 microtasks** (Promise `.then` / `queueMicrotask`) run next, drained to completion.
    
4. **libuv phases** run in their order (timers → poll → check). Macrotasks (timers, I/O callbacks, setImmediate) are scheduled into those phases.
    
5. **Within macrotasks**, the exact ordering depends on where you schedule them (from main script, from an I/O callback, etc.).
    

---

# Subtle behaviors / gotchas (what trips people)

- `process.nextTick()` can **starve the event loop** if it recursively schedules more `nextTick` callbacks. It runs before microtasks **and** before returning to libuv phases.
    
- `Promise.then()` and `queueMicrotask()` are microtasks and run **after** `process.nextTick` but **before** the next macrotask.
    
- `setImmediate()` preferentially runs **after the poll phase**; when scheduled from an I/O callback it usually fires before `setTimeout(..., 0)` scheduled in the same callback. When scheduled from the main script, `setTimeout(...,0)` often fires first. (Platform and timing can affect this.)
    
- `setTimeout(0)` is not “immediate” — it uses the timers phase and depends on the timers min resolution and the current tick state. Long synchronous work delays timers.
    
- Timers are implemented with scheduling/expiration logic (libuv uses a min-heap/timer-wheel-like structure) — they are **not** precise real-time timers; they expire when the event loop next reaches the timers phase after they become due.
    

---

# Practical, nerdy examples you can run

Save and run these in Linux (node v12+). Comments explain the exact reason for the output.

### Example 1 — nextTick vs promises vs queueMicrotask vs macrotasks

```js
// file: example-1.js
console.log('start');

setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));
Promise.resolve().then(() => console.log('promise'));
process.nextTick(() => console.log('nextTick'));
queueMicrotask(() => console.log('queueMicrotask'));

console.log('end');
```

**Typical output:**

```
start
end
nextTick
promise
queueMicrotask
timeout
immediate
```

**Why:** `nextTick` runs first (Node queue). Then V8 microtasks are drained in FIFO order: promise then queueMicrotask. After microtasks are drained, libuv proceeds to macrotasks (timers → check).

---

### Example 2 — setImmediate vs setTimeout(0) from main script vs from I/O

```js
// file: example-2.js
const fs = require('fs');

setTimeout(() => console.log('timeout from top'), 0);
setImmediate(() => console.log('immediate from top'));

fs.readFile(__filename, () => {
  console.log('readFile callback');
  setTimeout(() => console.log('timeout inside IO'), 0);
  setImmediate(() => console.log('immediate inside IO'));
});
```

**Typical output:**

```
timeout from top
immediate from top
readFile callback
immediate inside IO
timeout inside IO
```

**Why:** From the top-level the timers phase often runs before check, so `setTimeout(0)` runs before `setImmediate`. But inside an I/O callback (poll phase), the next phase executed is **check**, so `setImmediate` inside the I/O callback usually runs before `setTimeout` scheduled there.

---

### Example 3 — process.nextTick starvation (danger!)

```js
// file: example-3.js
function spin() {
  process.nextTick(() => {
    console.log('tick');
    spin();
  });
}

spin();
setTimeout(() => console.log('timer fired (will never run)'), 1000);
```

**What happens:** Your `process.nextTick` handler keeps scheduling itself — V8 and Node keep draining the `nextTick` queue and never return to the event loop’s macrotasks (so the timer never fires). **This can freeze your app.**

**Lesson:** Do not abuse `process.nextTick()` for recurring work; it can starve other work.

---

### Example 4 — long synchronous work delays everything

```js
// file: example-4.js
setTimeout(() => console.log('timer after blocking 50ms'), 50);
const start = Date.now();
while (Date.now() - start < 200) {
  // busy wait for 200ms — blocks the main thread
}
console.log('done blocking');
```

**Output example:**

```
done blocking
timer after blocking 50ms   // prints late (after blocking finishes)
```

**Why:** Timers can’t run until the main thread is free — synchronous CPU work blocks the entire Node single-threaded event loop.

---

### Example 5 — microtasks created inside I/O callback

```js
// file: example-5.js
const fs = require('fs');
fs.readFile(__filename, () => {
  console.log('io callback start');
  process.nextTick(() => console.log('nextTick inside io'));
  Promise.resolve().then(() => console.log('promise inside io'));
  console.log('io callback end');
});
console.log('top-level done');
```

**Typical output:**

```
top-level done
io callback start
io callback end
nextTick inside io
promise inside io
```

**Why:** The I/O callback executes in the poll phase. After that callback returns, Node drains `process.nextTick` then microtasks before continuing to the next phases.

---

# Implementation & internals notes (lower-level, nerdy)

- **`process.nextTick` is implemented in Node (not libuv)** — it’s a queue maintained by Node that is explicitly processed before the V8 job queue is run.
    
- **V8 microtask queue** (Promise job queue) is part of V8’s spec for the JS job queue; Node calls into V8 to drain this queue at appropriate times.
    
- **libuv’s poll phase** will block waiting for I/O if there are no immediate timers or check callbacks; if there are `setImmediate` callbacks queued, poll will end and allow check to run. This behavior is why `setImmediate` from I/O frequently fires before `setTimeout(0)` scheduled there.
    
- **Timers** are kept in a structure keyed by expiration time; libuv checks those expirations during the timers phase. Timers are cooperative — they execute when the event loop reaches that phase and finds them expired — so delays are common if the loop is busy.
    

---

# Practical rules-of-thumb for real code

- Use **Promises / async/await** for control flow — microtasks are efficient and readable.
    
- Avoid abusing **`process.nextTick()`** — it’s for small, immediate callbacks you need to run before returning to event loop _but_ don’t make it recursive.
    
- Use **`setImmediate()`** to schedule work to run _after_ the poll phase — useful to split up work across ticks to avoid blocking.
    
- Avoid heavy CPU work on the main thread — move it to **Worker Threads** or child processes.
    
- Don’t expect timers to be precise — treat them as scheduling hints.
    
- Use **`queueMicrotask()`** if you want microtask semantics explicitly (but `Promise.resolve().then(...)` is often adequate).
    

---

# How to explore / debug these behaviours

- Run the sample files above and tweak them to see ordering changes.
    
- Use `--trace-warnings`, `--inspect`, and `async_hooks` (Node core module) to trace async resource creation and execution. `async_hooks` can show you lifecycle of asynchronous resources (advanced).
    
- Use small experiments (like the ones above) to build intuition — timing and order are deterministic **given a single run** but small platform/timing differences may change order for timers vs setImmediate in edge cases.
    

---
