
This is a _core reason_ why Node can handle thousands of concurrent requests without breaking a sweat.

---

## **14. Non-Blocking I/O**

### **What it Means**

- **Blocking I/O** â†’ The thread _waits_ for a task (like file reading, database query, network request) to finish before doing anything else.
    
- **Non-Blocking I/O** â†’ The thread _delegates_ the task to the OS/libuv, and continues executing other code.  
    When the task is done, the callback (or Promise) is executed.
    

---

## **1. Blocking Example**

```js
const fs = require('fs');

console.log("Start reading file...");
const data = fs.readFileSync('sample.txt', 'utf8'); // Blocking
console.log(data);
console.log("End");
```

**Output:**

```
Start reading file...
[file contents]
End
```

ðŸ’¡ Here, Node is _stuck_ at `readFileSync` until the file is fully read â€” no other code runs.

---

## **2. Non-Blocking Example**

```js
const fs = require('fs');

console.log("Start reading file...");
fs.readFile('sample.txt', 'utf8', (err, data) => { // Non-blocking
    if (err) throw err;
    console.log(data);
});
console.log("End");
```

**Output:**

```
Start reading file...
End
[file contents]
```

ðŸ’¡ Node doesnâ€™t wait â€” it keeps running the rest of the script while the OS reads the file.

---

## **3. How Node Achieves This**

- JavaScript is **single-threaded** for execution.
    
- Node uses **libuv** (C library) to handle heavy lifting for I/O.
    
- Steps when you do an async file read:
    
    1. JS function call â†’ `fs.readFile(...)`
        
    2. Node passes request to **libuv**
        
    3. libuv delegates to OS or its own thread pool
        
    4. When done, result is placed in **event loopâ€™s callback queue**
        
    5. Event loop eventually calls your callback
        

---

## **4. Why Itâ€™s Powerful**

- While one request is waiting for I/O, Node can process others.
    
- This is why Node is great for:
    
    - APIs
        
    - Chat servers
        
    - Streaming services
        
    - Real-time dashboards
        

---

## **5. Quick Demo**

```js
const fs = require('fs');

console.log("Start");

fs.readFile('sample.txt', 'utf8', (err, data) => {
    console.log("File read complete");
});

setTimeout(() => console.log("Timer finished"), 0);

console.log("End");
```

**Possible Output:**

```
Start
End
Timer finished
File read complete
```

ðŸ’¡ Even though timer is `0ms`, file read is I/O bound, so it often finishes **after** the timer.

---

