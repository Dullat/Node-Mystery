

---

# 🌐 HTTP in Node.js — Core Concepts

### 1️⃣ `http.createServer`

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello, World!");
});

server.listen(3000, () => console.log("Server running on port 3000"));
```

- `req` is a **Readable stream** (data coming from client)
    
- `res` is a **Writable stream** (data going to client)
    

---

### 2️⃣ Request & Response Flow

- **Request** = headers + optional body
    
- **Response** = status line + headers + body
    

💡 **Tip:** Always set `Content-Type`, otherwise clients may misinterpret your response.  
Example:

```js
res.writeHead(200, { "Content-Type": "application/json" });
res.end(JSON.stringify({ msg: "ok" }));
```

---

### 3️⃣ Common Gotchas

⚠️ **Gotcha #1: Missing `res.end()`**

```js
// BAD: request hangs forever
res.write("Hello");
```

👉 Always call `res.end()` to finish the response.

---

⚠️ **Gotcha #2: Wrong headers timing**

```js
res.write("data");
res.writeHead(200, { "Content-Type": "text/plain" }); // ❌ Error
```

👉 You must call `writeHead` **before writing body**.

---

⚠️ **Gotcha #3: Large files**

```js
// ❌ Loads entire file in memory
fs.readFile("big.mp4", (err, data) => {
  res.end(data);
});

// ✅ Stream it directly
fs.createReadStream("big.mp4").pipe(res);
```

---

⚠️ **Gotcha #4: Blocking code**

```js
// ❌ Blocks entire server
const data = fs.readFileSync("big.txt", "utf8");
res.end(data);

// ✅ Async/non-blocking
fs.readFile("big.txt", "utf8", (err, data) => {
  res.end(data);
});
```

---

### 4️⃣ Best Practices

✅ **Use Streams** → efficient for large files, avoids memory blowup  
✅ **Always set proper headers** (`Content-Type`, `Content-Length`, `Cache-Control`)  
✅ **Error handling** → don’t let server crash

```js
server.on("error", err => console.error("Server Error:", err));
```

✅ **Graceful shutdown** → close connections properly on exit  
✅ **Security basics**:

- Don’t echo raw user input in HTML → XSS
    
- Use `helmet` middleware (when you move to Express)  
    ✅ **Log requests** (method, path, status, time)
    

---

### 5️⃣ Example: File server with good practices

```js
const http = require("http");
const fs = require("fs");
const path = require("path");

const server = http.createServer((req, res) => {
  if (req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end("<h1>Welcome</h1>");
  } else if (req.url === "/file") {
    const filePath = path.join(__dirname, "big.txt");

    // Stream file with error handling
    const stream = fs.createReadStream(filePath);
    stream.on("error", err => {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Server error: " + err.message);
    });
    res.writeHead(200, { "Content-Type": "text/plain" });
    stream.pipe(res);
  } else {
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("Not Found");
  }
});

server.listen(3000, () => console.log("Server running on port 3000"));
```

---

### 6️⃣ When to stop using bare `http`

Bare Node HTTP server is great for learning and **tiny apps**, but quickly you’ll hit pain points:

- Routing is manual (`if/else` on `req.url`)
    
- Parsing JSON/form bodies is manual
    
- Headers & status codes are verbose
    
- No middlewares
    

👉 That’s why we switch to **Express** — it solves these.

---

⚡ So, if you’re good, we can do:

1. Play with **low-level HTTP** (to understand how Express is built).
    
2. Then jump into **Express**, where you’ll build practical APIs with best practices.
    
---