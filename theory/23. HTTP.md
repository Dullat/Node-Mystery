

---

# ğŸŒ HTTP in Node.js â€” Core Concepts

### 1ï¸âƒ£ `http.createServer`

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello, World!");
});

server.listen(3000, () => console.log("Server running on port 3000"));
```

- `req` is a **Readable stream** (data coming from client)
    
- `res` is a **Writable stream** (data going to client)
    

---

### 2ï¸âƒ£ Request & Response Flow

- **Request** = headers + optional body
    
- **Response** = status line + headers + body
    

ğŸ’¡ **Tip:** Always set `Content-Type`, otherwise clients may misinterpret your response.  
Example:

```js
res.writeHead(200, { "Content-Type": "application/json" });
res.end(JSON.stringify({ msg: "ok" }));
```

---

### 3ï¸âƒ£ Common Gotchas

âš ï¸ **Gotcha #1: Missing `res.end()`**

```js
// BAD: request hangs forever
res.write("Hello");
```

ğŸ‘‰ Always call `res.end()` to finish the response.

---

âš ï¸ **Gotcha #2: Wrong headers timing**

```js
res.write("data");
res.writeHead(200, { "Content-Type": "text/plain" }); // âŒ Error
```

ğŸ‘‰ You must call `writeHead` **before writing body**.

---

âš ï¸ **Gotcha #3: Large files**

```js
// âŒ Loads entire file in memory
fs.readFile("big.mp4", (err, data) => {
  res.end(data);
});

// âœ… Stream it directly
fs.createReadStream("big.mp4").pipe(res);
```

---

âš ï¸ **Gotcha #4: Blocking code**

```js
// âŒ Blocks entire server
const data = fs.readFileSync("big.txt", "utf8");
res.end(data);

// âœ… Async/non-blocking
fs.readFile("big.txt", "utf8", (err, data) => {
  res.end(data);
});
```

---

### 4ï¸âƒ£ Best Practices

âœ… **Use Streams** â†’ efficient for large files, avoids memory blowup  
âœ… **Always set proper headers** (`Content-Type`, `Content-Length`, `Cache-Control`)  
âœ… **Error handling** â†’ donâ€™t let server crash

```js
server.on("error", err => console.error("Server Error:", err));
```

âœ… **Graceful shutdown** â†’ close connections properly on exit  
âœ… **Security basics**:

- Donâ€™t echo raw user input in HTML â†’ XSS
    
- Use `helmet` middleware (when you move to Express)  
    âœ… **Log requests** (method, path, status, time)
    

---

### 5ï¸âƒ£ Example: File server with good practices

```js
const http = require("http");
const fs = require("fs");
const path = require("path");

const server = http.createServer((req, res) => {
  if (req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end("<h1>Welcome</h1>");
  } else if (req.url === "/file") {
    const filePath = path.join(__dirname, "big.txt");

    // Stream file with error handling
    const stream = fs.createReadStream(filePath);
    stream.on("error", err => {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Server error: " + err.message);
    });
    res.writeHead(200, { "Content-Type": "text/plain" });
    stream.pipe(res);
  } else {
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("Not Found");
  }
});

server.listen(3000, () => console.log("Server running on port 3000"));
```

---

### 6ï¸âƒ£ When to stop using bare `http`

Bare Node HTTP server is great for learning and **tiny apps**, but quickly youâ€™ll hit pain points:

- Routing is manual (`if/else` on `req.url`)
    
- Parsing JSON/form bodies is manual
    
- Headers & status codes are verbose
    
- No middlewares
    

ğŸ‘‰ Thatâ€™s why we switch to **Express** â€” it solves these.

---

âš¡ So, if youâ€™re good, we can do:

1. Play with **low-level HTTP** (to understand how Express is built).
    
2. Then jump into **Express**, where youâ€™ll build practical APIs with best practices.
    
---