

---

# **Synchronous vs Asynchronous in Node.js**

### **1. Synchronous Code**

- Runs **top to bottom**, **one line at a time**.
    
- Each task **blocks** the next until itâ€™s finished.
    
- Good for simple tasks that complete quickly.
    
- **Problem:** Long-running tasks can freeze the whole application.
    

**Example:**

```js
console.log("Start");

function longTask() {
  // Simulate heavy CPU work
  for (let i = 0; i < 1e9; i++) {}
}

longTask(); // Blocking

console.log("End");
```

**Output:**

```
Start
End  // Printed only after the longTask finishes
```

ğŸ’¡ Here, nothing else can happen until `longTask()` completes.

---

### **2. Asynchronous Code**

- Runs **without blocking** other tasks.
    
- Delegates long tasks (like file read, network requests) to **libuv**.
    
- Uses callbacks, promises, or async/await to handle results later.
    

**Example:**

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout done");
}, 2000);

console.log("End");
```

**Output:**

```
Start
End
Timeout done
```

ğŸ’¡ `setTimeout` is handed to libuv â†’ event loop waits â†’ callback runs later.

---

### **3. Comparing Sync vs Async in a Real Task**

Letâ€™s read a file **synchronously** and **asynchronously**.

```js
const fs = require('fs');

// Sync read
console.log("Sync read start");
const dataSync = fs.readFileSync('test.txt', 'utf8');
console.log(dataSync);
console.log("Sync read end");

// Async read
console.log("Async read start");
fs.readFile('test.txt', 'utf8', (err, dataAsync) => {
  console.log(dataAsync);
});
console.log("Async read end");
```

**Possible Output:**

```
Sync read start
[contents of file]
Sync read end
Async read start
Async read end
[contents of file]
```

ğŸ’¡ Synchronous blocks until the file is read.  
ğŸ’¡ Asynchronous immediately moves on, and prints file contents when ready.

---

### **4. Why Async is Crucial in Node.js**

- Node is **single-threaded for JS** â€” if you block the thread, nothing else runs.
    
- Async lets Node handle **thousands of concurrent requests** efficiently.
    
- This is why Node is popular for APIs, chat apps, and streaming â€” I/O heavy but CPU-light workloads.
    

---

### **5. Fun Async Demo (Proof Node Isnâ€™t Waiting)**

```js
console.log("ğŸ Start");

setTimeout(() => console.log("â³ Timer 1"), 0);
setTimeout(() => console.log("â³ Timer 2"), 0);

Promise.resolve().then(() => console.log("ğŸ’ Promise"));
process.nextTick(() => console.log("ğŸš€ NextTick"));

console.log("ğŸ End");
```

**Output:**

```
ğŸ Start
ğŸ End
ğŸš€ NextTick
ğŸ’ Promise
â³ Timer 1
â³ Timer 2
```

ğŸ’¡ Even `setTimeout(0)` doesnâ€™t run instantly â€” event loop phases still matter.

---
