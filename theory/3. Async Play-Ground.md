
---

## **Async Behavior Demo**

Create a file called `async-fun.js`:

```js
console.log("1️⃣ Start of Script");

// Schedule a timeout (async)
setTimeout(() => {
  console.log("⏳ Timeout finished (2 sec)");
}, 2000);

// Schedule an immediate callback (async)
setImmediate(() => {
  console.log("⚡ setImmediate callback");
});

// Schedule a promise (microtask)
Promise.resolve().then(() => {
  console.log("💎 Promise resolved");
});

// Blocking code (sync)
for (let i = 0; i < 5; i++) {
  console.log(`🔁 Loop iteration ${i + 1}`);
}

console.log("🏁 End of Script");
```

---

### **Run it**

```bash
node async-fun.js
```

**Example Output (order will be consistent):**

```
1️⃣ Start of Script
🔁 Loop iteration 1
🔁 Loop iteration 2
🔁 Loop iteration 3
🔁 Loop iteration 4
🔁 Loop iteration 5
🏁 End of Script
💎 Promise resolved
⚡ setImmediate callback
⏳ Timeout finished (2 sec)
```

---

### **Why this order?**

- **Synchronous code** (the loop) runs first — Node won’t start async tasks until sync work is done.
    
- **Promise** callbacks go in the **microtask queue** — they run right after sync code finishes.
    
- **setImmediate** callbacks run in the **check phase** of the event loop.
    
- **setTimeout** runs in the **timers phase** after the given delay.
    

---

💡 **Try Playing Around**

1. Change `2000` in `setTimeout` to `0` — see if it runs before `Promise.resolve()` (it won’t 😉).
    
2. Add `fs.readFile()` to test file system async.
    
3. Add a `while(true)` loop to block the event loop — watch how everything freezes.
    

---
