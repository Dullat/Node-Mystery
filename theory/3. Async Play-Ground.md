
---

## **Async Behavior Demo**

Create a file called `async-fun.js`:

```js
console.log("1ï¸âƒ£ Start of Script");

// Schedule a timeout (async)
setTimeout(() => {
  console.log("â³ Timeout finished (2 sec)");
}, 2000);

// Schedule an immediate callback (async)
setImmediate(() => {
  console.log("âš¡ setImmediate callback");
});

// Schedule a promise (microtask)
Promise.resolve().then(() => {
  console.log("ðŸ’Ž Promise resolved");
});

// Blocking code (sync)
for (let i = 0; i < 5; i++) {
  console.log(`ðŸ” Loop iteration ${i + 1}`);
}

console.log("ðŸ End of Script");
```

---

### **Run it**

```bash
node async-fun.js
```

**Example Output (order will be consistent):**

```
1ï¸âƒ£ Start of Script
ðŸ” Loop iteration 1
ðŸ” Loop iteration 2
ðŸ” Loop iteration 3
ðŸ” Loop iteration 4
ðŸ” Loop iteration 5
ðŸ End of Script
ðŸ’Ž Promise resolved
âš¡ setImmediate callback
â³ Timeout finished (2 sec)
```

---

### **Why this order?**

- **Synchronous code** (the loop) runs first â€” Node wonâ€™t start async tasks until sync work is done.
    
- **Promise** callbacks go in the **microtask queue** â€” they run right after sync code finishes.
    
- **setImmediate** callbacks run in the **check phase** of the event loop.
    
- **setTimeout** runs in the **timers phase** after the given delay.
    

---

ðŸ’¡ **Try Playing Around**

1. Change `2000` in `setTimeout` to `0` â€” see if it runs before `Promise.resolve()` (it wonâ€™t ðŸ˜‰).
    
2. Add `fs.readFile()` to test file system async.
    
3. Add a `while(true)` loop to block the event loop â€” watch how everything freezes.
    

---
